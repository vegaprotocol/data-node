package entities

import (
	"encoding/hex"
	"fmt"
	"time"

	"code.vegaprotocol.io/protos/vega"
)

type Account struct {
	ID       int64
	PartyID  []byte
	AssetID  []byte
	MarketID []byte
	Type     vega.AccountType
	VegaTime time.Time
}

func (a Account) String() string {
	return fmt.Sprintf("{ID: %s}", hex.EncodeToString(a.AssetID))
}

func AccountFromProto(va vega.Account) (Account, error) {
	account := Account{}
	var err error

	if va.Owner == "*" {
		account.PartyID = []byte("")
	} else {
		if account.PartyID, err = hex.DecodeString(va.Owner); err != nil {
			return Account{}, fmt.Errorf("Can't decode party hex string %v", va.Owner)
		}
	}

	account.AssetID = MakeAssetID(va.Asset)

	if va.MarketId == "!" {
		account.MarketID = []byte("")
	} else {
		if account.MarketID, err = hex.DecodeString(va.MarketId); err != nil {
			return Account{}, fmt.Errorf("Can't decode market hex string %v", va.MarketId)
		}
	}

	account.Type = va.Type
	return account, nil
}

// AccountFromAccountID takes an ID generated by vega core and uses the information in it to create
// an account struct. In vega core, account IDs are generated by concatenating (party id, market id,
// asset id, account type) with '!' indicating no market, and "*" indicating the system owner party.
// (see collateral/engine.go). It's a bit unfortunate that this internal detail leaks out of core,
// but it's required for now as it's the only way we can extract all the required account information
// out of an TransferResponse message.
func AccountFromAccountID(id string) (Account, error) {
	var a Account
	var err error
	var offset int

	// Market ID is first, '!' indicates no market
	if id[offset] == '!' {
		offset++
		a.MarketID = []byte{}
	} else {
		if len(id) < 64 {
			return Account{}, fmt.Errorf("account id too short: %v", id)
		}

		a.MarketID, err = hex.DecodeString(id[0:64])
		if err != nil {
			return Account{}, fmt.Errorf("market id not hex: %v", id)
		}
		offset += 64
	}

	// Party ID is next, '*' indicates system owner
	if id[offset] == '*' {
		a.PartyID = []byte{}
		offset++
	} else {
		if len(id) < offset+64 {
			return Account{}, fmt.Errorf(" %v", id)
		}

		// TODO - missing last dig
		a.PartyID, err = hex.DecodeString(id[offset : offset+64])
		if err != nil {
			return Account{}, fmt.Errorf("party id not hex: %v", id)
		}
		offset += 64
	}

	// Now Asset ID
	if offset >= (len(id) - 1) {
		return Account{}, fmt.Errorf("account id too short %v", id)
	}

	a.AssetID = MakeAssetID(id[offset : len(id)-1])
	a.Type = vega.AccountType(id[len(id)-1] - 48)
	return a, nil
}
